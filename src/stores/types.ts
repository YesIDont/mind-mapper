import { ObjectOfVectors, SavedStateType, Vector } from '../types/baseTypes';
import { Pointer } from './pointer';
import { Thought } from './Thought';

export type OverlapResult = {
  other: Thought;
  amount: Vector;
  isColliding: boolean;
};

export type TAxis = 'x' | 'y';

export type TStore = /* View & */ {
  connectorsCurveDividerWidth: number;
  defaultSpawnGap: Vector;
  highlightId?: string;
  isDrawingLocked: boolean;
  isGroupDragOn: boolean;
  isInitialized: boolean;
  initialThoughtWidth: number;
  rootThought: Thought;
  savedMindMap: string;
  scale: number;
  selectionId?: string;
  thoughts: Thought[];
  pointer: Pointer;
  initialize(): void;
  addThought(position: Vector, isRoot?: boolean, parentId?: string, initText?: string, existingId?: string): Thought;
  getThoughtById(id: string): Thought | undefined;
  getNewID(): string;
  getHighlightedThought(): Thought | undefined;
  getSelectedThought(): Thought | undefined;
  saveChildrenRelativePosition(id: string): void;
  restoreChildrenRelativePosition(id: string): void;
  getChildrenIds(parentId: string, includeGrandChildren?: boolean): string[];
  getChildren(parentId: string, includeGrandChildren?: boolean): Thought[];
  addChildThought(newParentId: string, childId: string): void;
  removeChildThought(parentId: string, childToBeRemovedId: string): void;
  isParentOf(parentId: string, unknownChildId: string, includeGrandChildren?: boolean): boolean;
  isChildOf(childId: string, potentialParentId: string): boolean;
  postNewThoughActions(newSibling: Thought): void;
  createChildThought(thought: Thought): void;
  createSiblingThought(thought: Thought): void;
  setHighlight(thoughtId: string): void;
  clearHighlight(): void;
  setSelection(newSelectionId: string): void;
  clearSelection(): void;
  stopEditing(checkDefaultValue?: boolean): void;
  setIsGroupDragOn(isOn: boolean): void;
  removeThought(thought: Thought): void;
  removeIfEmpty(thought: Thought): void;
  editSelection(): void;
  isParentOnLeft(thoughtId: string): boolean;
  getConnectorPoints(thoughtId: string): ObjectOfVectors;
  updateSelectionContent(value: string): void;
  isOverlappingWith(thought: Thought, other: Thought): OverlapResult;
  findOverlapsFor(thought: Thought): OverlapResult[];
  resolveOverlaps(thought: Thought, axis?: TAxis): Thought;
  findClosestOverlapFor(thought: Thought): void;
  setPositionAsync(thoughtId: string, newPosition: Vector, callback?: () => void): void;
  updateWorkspaceSize(): void;
  saveCurrentMindMapAsJSON(): void;
  getCurrentMindMapState(): SavedStateType;
  deserializeMindMap(saved: SavedStateType): void;
  setDrawLock(isDrawingLocked: boolean): void;
  draw(): void;
  updateSingleItem(item: Thought): void;
  onMouseMove(event: MouseEvent): void;
  customOnFinishHydration(): void;
};
